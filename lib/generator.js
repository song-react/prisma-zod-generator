#!/usr/bin/env node
Object.defineProperty(exports,"__esModule",{value:!0});const U=require("@prisma/generator-helper"),I=require("fs"),A=require("path"),F={String:"z.string()",Int:"z.number().int()",BigInt:"z.bigint()",Float:"z.number()",Decimal:"z.number()",Boolean:"z.boolean()",DateTime:"z.date()",Json:"z.any()",Bytes:"z.instanceof(Buffer)"};let b=new Map;const P=/z\.(string|number|bigint|boolean|date|symbol|any|unknown|never|void|undefined|null|literal|object|map|set|record|enum)(?!\s*\()/g,x=/\.array\(\s*(\.[^)]*)\)/g;function r(t){return"  ".repeat(t)}function w(t){return t.replace(P,(s,e)=>`z.${e}()`).replace(x,(s,e)=>`.array()${e}`)}function Z(t){if(!t)return;const s=t.trim();if(!s.startsWith("@z"))return;let e=s;e=e.replace(/^@zod\s*\.?/,"").replace(/^@z\s*\.?/,"");const o=e.match(/\.use\(([^]+)\)\s*$/s);if(o)return w(o[1].trim());if(!e.startsWith("z"))e=`z.${e.startsWith(".")?e.slice(1):e}`;else if(!e.startsWith("z."))e=`z.${e}`;return w(e)}function E(t,s){if(!s.isList)return t;if(t.includes(".array(")||t.startsWith("z.array("))return t;return`z.array(${t})`}function M(t,s){if(s.isList)return t;if(!s.isRequired&&!t.includes(".nullable(")&&!t.includes(".nullish("))t=`${t}.nullable()`;return t}function N(t){if(t.trimEnd().endsWith(".optional()"))return t;return`${t}.optional()`}function W(t,s){return!s.isRequired||s.hasDefaultValue?N(t):t}function O(t,s){let o=Z(t.documentation);if(!o)if(t.kind==="enum"){const i=b.get(t.type);if(i&&i.length>0){if(!s.enumUsage.has(t.type))s.enumUsage.set(t.type,i);o=`${t.type}Schema`}else o="z.string()"}else o=F[t.type]??"z.any()";o=E(o,t);o=M(o,t);o=W(o,t);return o}function R(t){const s=new Map;for(const e of t.fields)if(e.isId||e.isUnique)s.set(e.name,e);if(t.primaryKey)for(const e of t.primaryKey.fields){const o=t.fields.find((i)=>i.name===e);if(o)s.set(e,o)}for(const e of t.uniqueFields)for(const o of e){const i=t.fields.find((n)=>n.name===o);if(i)s.set(o,i)}return Array.from(s.values())}function _(t,s){const e=new Map(t.fields.map((c)=>[c.name,c])),o=[],i=new Set,n=(c)=>{const u=Array.from(new Set(c));if(u.length===0)return;const h=u.slice().sort().join("|");if(i.has(h))return;const z=u.map((f)=>e.get(f)).filter((f)=>Boolean(f));if(z.length!==u.length)return;i.add(h);o.push(z)};for(const c of s)n([c.name]);for(const c of t.uniqueFields??[])n(c);if(t.primaryKey)n(t.primaryKey.fields);const l=Array.from(new Set(s.map((c)=>c.name)));if(l.length>1)n(l);return o}function v(t,s){return s?`z.lazy(() => ${t})`:t}function D(t){return`whereRelationLazy(() => ${t})`}function C(t,s,e){const o=`${t.type}WhereInputSchema`,i=t.type===s||!e.emittedModels.has(t.type);let n=t.isList?D(o):v(o,i);if(t.type===s&&!t.isList){const l=`Prisma.${s}WhereInput[${JSON.stringify(t.name)}]`;n=`${n} as z.ZodType<${l}>`}return n}function k(t,s){return`${t}Schema.shape[${JSON.stringify(s)}]`}function q(t,s){if(s.isList)return`z.custom<${`Prisma.${t}WhereInput[${JSON.stringify(s.name)}]`}>()`;return k(t,s.name)}function B(t,s){const{lines:e}=s,o=t.fields.filter((a)=>a.kind!=="object"),i=t.fields.filter((a)=>a.kind==="object"),n=t.name,l=`${n}IncludeSchema`,c=`${n}IncludeObjectSchema`,u=`${n}WhereInputSchema`,h=`${n}WhereUniqueInputSchema`,z=`${n}WhereInputObjectSchema`,f=`${n}CreateInputSchema`,S=`${n}UpdateInputSchema`;e.push(`// ${n}`);e.push(`export const ${n}Schema = z.object({`);for(const a of o){const p=O(a,s);e.push(`${r(1)}${a.name}: ${p},`)}e.push("}).strip();","");e.push(`export const ${u}: z.ZodType<Prisma.${n}WhereInput> = z.lazy(() => ${z});`,"");e.push(`const ${z} = z.object({`);for(const a of o)e.push(`${r(1)}${a.name}: ${q(n,a)},`);for(const a of i)e.push(`${r(1)}${a.name}: ${C(a,n,s)},`);e.push(`${r(1)}AND: z.union([z.lazy(() => ${u}), z.lazy(() => ${u}).array()]),`);e.push(`${r(1)}OR: z.lazy(() => ${u}).array(),`);e.push(`${r(1)}NOT: z.union([z.lazy(() => ${u}), z.lazy(() => ${u}).array()]),`);e.push("}).partial().strip();","");const T=R(t);if(T.length===0)e.push(`export const ${h} = ${u} as z.ZodType<Prisma.${n}WhereUniqueInput>;`,"");else{const a=_(t,T),p=[];for(const m of a){const $=[];$.push("z.intersection(");$.push(`${r(1)}z.object({`);for(const y of m){const g=q(n,y);$.push(`${r(2)}${y.name}: ${g},`)}$.push(`${r(1)}}),`);$.push(`${r(1)}${u}`);$.push(")");p.push($.join(`
`))}const d=p.length===1?p[0]:`z.union([
${p.map((m)=>`${r(1)}${m}`).join(`,
`)}
])`;e.push(`export const ${h} = ${d} as z.ZodType<Prisma.${n}WhereUniqueInput>;`,"")}const j=i.filter((a)=>a.isList);e.push(`export const ${l} = z.object({`);for(const a of i){const p=`${a.type}FindManyArgsSchema`,d=`${a.type}FindUniqueArgsSchema`,m=a.isList?p:d;e.push(`${r(2)}${a.name}: z.union([z.boolean()/*, z.lazy(() => ${m})*/]),`)}if(j.length>0){e.push(`${r(2)}_count: z.union([z.boolean(), z.object({`);e.push(`${r(3)}select: z.object({`);for(const a of j)e.push(`${r(4)}${a.name}: z.union([z.boolean()/*, z.object({ where: ${a.type}WhereInputSchema.optional()}).strip()*/]).optional(),`);e.push(`${r(3)}}).partial().strip() satisfies z.ZodType<Prisma.${n}CountOutputTypeSelect> `);e.push(`${r(2)}}).strip() satisfies z.ZodType<Prisma.${n}CountOutputTypeDefaultArgs>`);e.push(`${r(1)}])`)}e.push(`}).partial().strip() satisfies z.ZodType<Prisma.${n}Include>;`,"");const L=i.flatMap((a)=>a.relationFromFields??[]);e.push(`export const ${f} = ${n}Schema.omit({ ${o.filter((a)=>a.isId||L.includes(a.name)).map((a)=>`${a.name}: true`).join(", ")} }).extend({`);for(const a of i){const p=`${a.type}CreateInputSchema.omit({${n}: true}))`,d=a.isList?`z.union([z.lazy(() => ${p}), z.lazy(() => ${p}).array()])`:`z.lazy(() => ${p})`,m=`${a.type}WhereUniqueInputSchema`,$=a.isList?`z.union([z.lazy(() => ${m}), z.lazy(() => ${m}).array()])`:`z.lazy(() => ${m})`,y=`z.object({
    // ${r(0)}create: ${d}.optional(),
    ${r(0)}connect: ${$}.optional(),
  ${r(0)}}).strip()`,g=a.isList?N(y):W(y,a);e.push(`${r(1)}${a.name}: ${g},`)}e.push("});","");e.push(`export const ${S} = ${f}.partial();`,"");e.push(`export const ${n}FindManyArgsSchema = z.object({`);e.push(`${r(1)}include: ${l}.default({}),`);e.push(`${r(1)}where: ${u}.optional(),`);e.push(`${r(1)}cursor: ${h}.optional(),`);e.push(`${r(1)}take: z.number().optional(),`);e.push(`${r(1)}skip: z.number().optional(),`);e.push(`}).strip() satisfies z.ZodType<Prisma.${n}FindManyArgs>;`,"");e.push(`export const ${n}FindUniqueArgsSchema = z.object({`);e.push(`${r(1)}include: ${l},`);e.push(`${r(1)}where: ${h},`);e.push(`}).strip() satisfies z.ZodType<Prisma.${n}FindUniqueArgs>;`,"");e.push(`export const ${n}CreateArgsSchema = z.object({`);e.push(`${r(1)}data: ${f},`);e.push(`}).strip() satisfies z.ZodType<Prisma.${n}CreateArgs>;`,"");e.push(`export const ${n}UpdateArgsSchema = z.object({`);e.push(`${r(1)}data: ${S},`);e.push(`${r(1)}where: ${h},`);e.push(`}).strip() satisfies z.ZodType<Prisma.${n}UpdateArgs>;`,"");e.push(`export const ${n}DeleteArgsSchema = z.object({`);e.push(`${r(1)}include: ${l}.optional(),`);e.push(`${r(1)}where: ${h},`);e.push(`}).strip() satisfies z.ZodType<Prisma.${n}DeleteArgs>;`,"");s.emittedModels.add(n)}(0,U.generatorHandler)({onManifest(){return{version:"1.0.0",prettyName:"Prisma Zod Generator",defaultOutput:"../node_modules/@prisma/zod"}},async onGenerate(t){const s=t.generator.output?.value??(0,A.join)(process.cwd(),"node_modules/@prisma/zod");(0,I.mkdirSync)(s,{recursive:!0});b=new Map;for(const i of t.dmmf.datamodel.enums)b.set(i.name,i.values.map(({name:n})=>n));const e={lines:[],enumUsage:new Map,emittedModels:new Set};for(const i of t.dmmf.datamodel.models)B(i,e);const o=[];o.push("import { z } from 'zod';");o.push("import type { Prisma } from '@prisma/client';","");if(e.enumUsage.size>0){for(const[i,n]of e.enumUsage){const l=n.map((c)=>`'${c}'`).join(", ");o.push(`const ${i}Schema = z.enum([${l}] as const);`)}o.push("")}o.push(`type WhereRelationFilter<T> = {
  some?: T;
  none?: T;
  every?: T;
};`,"");o.push(`const whereRelationLazy = <T>(getSchema: () => z.ZodType<T>): z.ZodType<WhereRelationFilter<T>> => z.object({
      some: z.lazy(getSchema),
      none: z.lazy(getSchema),
      every: z.lazy(getSchema),
    })
    .partial()
    .strip();`,"");o.push(`const includeRelationLazy = <Schema extends z.ZodTypeAny>(
  getArgsSchema: () => Schema
): z.ZodType<boolean | z.infer<Schema>> =>
  z.union([z.boolean(), z.lazy(getArgsSchema)]) as z.ZodType<boolean | z.infer<Schema>>;`,"");o.push("// 自动生成，请勿手动修改","");o.push(...e.lines);(0,I.writeFileSync)((0,A.join)(s,"index.ts"),o.join(`
`))}});